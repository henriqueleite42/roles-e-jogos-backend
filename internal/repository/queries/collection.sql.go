// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: collection.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCollectiveCollection = `-- name: GetCollectiveCollection :many
SELECT
  g."id" AS "game_id",
  g."name",
  g."description",
  g."kind",
  g."min_amount_of_players",
  g."max_amount_of_players",
  g."ludopedia_id",
  g."ludopedia_url",
  g."icon_path",
  json_agg(
    json_build_object(
      'account_id', a."id",
      'handle', a."handle",
      'avatar_path', a."avatar_path"
    ) ORDER BY a."handle"
  ) FILTER (WHERE a.id IS NOT NULL) AS owners
FROM
  "games" g
INNER JOIN
  "personal_collections" pc ON g."id" = pc."game_id"
INNER JOIN
  "accounts" a ON pc."account_id" = a."id"
WHERE
	g."kind" = $1
	AND
	g."name" > $2
GROUP BY
  g."id"
ORDER BY
  g."name" ASC
LIMIT $3
`

type GetCollectiveCollectionParams struct {
	Kind  KindEnum
	Name  string
	Limit int32
}

type GetCollectiveCollectionRow struct {
	GameID             int32
	Name               string
	Description        string
	Kind               KindEnum
	MinAmountOfPlayers int32
	MaxAmountOfPlayers int32
	LudopediaID        pgtype.Int4
	LudopediaUrl       pgtype.Text
	IconPath           pgtype.Text
	Owners             []byte
}

func (q *Queries) GetCollectiveCollection(ctx context.Context, arg GetCollectiveCollectionParams) ([]GetCollectiveCollectionRow, error) {
	rows, err := q.db.Query(ctx, getCollectiveCollection, arg.Kind, arg.Name, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectiveCollectionRow
	for rows.Next() {
		var i GetCollectiveCollectionRow
		if err := rows.Scan(
			&i.GameID,
			&i.Name,
			&i.Description,
			&i.Kind,
			&i.MinAmountOfPlayers,
			&i.MaxAmountOfPlayers,
			&i.LudopediaID,
			&i.LudopediaUrl,
			&i.IconPath,
			&i.Owners,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectiveCollectionAllFilters = `-- name: GetCollectiveCollectionAllFilters :many
SELECT
  g."id" AS "game_id",
  g."name",
  g."description",
  g."kind",
  g."min_amount_of_players",
  g."max_amount_of_players",
  g."ludopedia_id",
  g."ludopedia_url",
  g."icon_path",
  json_agg(
    json_build_object(
      'account_id', a."id",
      'handle', a."handle",
      'avatar_path', a."avatar_path"
    ) ORDER BY a."handle"
  ) FILTER (WHERE a.id IS NOT NULL) AS owners
FROM
  "games" g
INNER JOIN
  "personal_collections" pc ON g."id" = pc."game_id"
INNER JOIN
  "accounts" a ON pc."account_id" = a."id"
WHERE
	g."kind" = $1
	AND
	g."name" LIKE $2
	AND
	pc."account_id" = $3
	AND
	g."max_amount_of_players" >= $4
	AND
	g."name" > $5
GROUP BY
  g."id"
ORDER BY
	g."name" ASC
LIMIT $6
`

type GetCollectiveCollectionAllFiltersParams struct {
	Kind               KindEnum
	Name               string
	AccountID          int32
	MaxAmountOfPlayers int32
	Name_2             string
	Limit              int32
}

type GetCollectiveCollectionAllFiltersRow struct {
	GameID             int32
	Name               string
	Description        string
	Kind               KindEnum
	MinAmountOfPlayers int32
	MaxAmountOfPlayers int32
	LudopediaID        pgtype.Int4
	LudopediaUrl       pgtype.Text
	IconPath           pgtype.Text
	Owners             []byte
}

func (q *Queries) GetCollectiveCollectionAllFilters(ctx context.Context, arg GetCollectiveCollectionAllFiltersParams) ([]GetCollectiveCollectionAllFiltersRow, error) {
	rows, err := q.db.Query(ctx, getCollectiveCollectionAllFilters,
		arg.Kind,
		arg.Name,
		arg.AccountID,
		arg.MaxAmountOfPlayers,
		arg.Name_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectiveCollectionAllFiltersRow
	for rows.Next() {
		var i GetCollectiveCollectionAllFiltersRow
		if err := rows.Scan(
			&i.GameID,
			&i.Name,
			&i.Description,
			&i.Kind,
			&i.MinAmountOfPlayers,
			&i.MaxAmountOfPlayers,
			&i.LudopediaID,
			&i.LudopediaUrl,
			&i.IconPath,
			&i.Owners,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectiveCollectionByGameName = `-- name: GetCollectiveCollectionByGameName :many
SELECT
  g."id" AS "game_id",
  g."name",
  g."description",
  g."kind",
  g."min_amount_of_players",
  g."max_amount_of_players",
  g."ludopedia_id",
  g."ludopedia_url",
  g."icon_path",
  json_agg(
    json_build_object(
      'account_id', a."id",
      'handle', a."handle",
      'avatar_path', a."avatar_path"
    ) ORDER BY a."handle"
  ) FILTER (WHERE a.id IS NOT NULL) AS owners
FROM
  "games" g
INNER JOIN
  "personal_collections" pc ON g."id" = pc."game_id"
INNER JOIN
  "accounts" a ON pc."account_id" = a."id"
WHERE
	g."kind" = $1
	AND
	g."name" LIKE $2
	AND
	g."name" > $3
GROUP BY
  g."id"
ORDER BY
	g."name" ASC
LIMIT $4
`

type GetCollectiveCollectionByGameNameParams struct {
	Kind   KindEnum
	Name   string
	Name_2 string
	Limit  int32
}

type GetCollectiveCollectionByGameNameRow struct {
	GameID             int32
	Name               string
	Description        string
	Kind               KindEnum
	MinAmountOfPlayers int32
	MaxAmountOfPlayers int32
	LudopediaID        pgtype.Int4
	LudopediaUrl       pgtype.Text
	IconPath           pgtype.Text
	Owners             []byte
}

func (q *Queries) GetCollectiveCollectionByGameName(ctx context.Context, arg GetCollectiveCollectionByGameNameParams) ([]GetCollectiveCollectionByGameNameRow, error) {
	rows, err := q.db.Query(ctx, getCollectiveCollectionByGameName,
		arg.Kind,
		arg.Name,
		arg.Name_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectiveCollectionByGameNameRow
	for rows.Next() {
		var i GetCollectiveCollectionByGameNameRow
		if err := rows.Scan(
			&i.GameID,
			&i.Name,
			&i.Description,
			&i.Kind,
			&i.MinAmountOfPlayers,
			&i.MaxAmountOfPlayers,
			&i.LudopediaID,
			&i.LudopediaUrl,
			&i.IconPath,
			&i.Owners,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectiveCollectionByMaxAmountOfPlayers = `-- name: GetCollectiveCollectionByMaxAmountOfPlayers :many
SELECT
  g."id" AS "game_id",
  g."name",
  g."description",
  g."kind",
  g."min_amount_of_players",
  g."max_amount_of_players",
  g."ludopedia_id",
  g."ludopedia_url",
  g."icon_path",
  json_agg(
    json_build_object(
      'account_id', a."id",
      'handle', a."handle",
      'avatar_path', a."avatar_path"
    ) ORDER BY a."handle"
  ) FILTER (WHERE a.id IS NOT NULL) AS owners
FROM
  "games" g
INNER JOIN
  "personal_collections" pc ON g."id" = pc."game_id"
INNER JOIN
  "accounts" a ON pc."account_id" = a."id"
WHERE
	g."kind" = $1
	AND
	g."max_amount_of_players" >= $2
	AND
	g."name" > $3
GROUP BY
  g."id"
ORDER BY
	g."name" ASC
LIMIT $4
`

type GetCollectiveCollectionByMaxAmountOfPlayersParams struct {
	Kind               KindEnum
	MaxAmountOfPlayers int32
	Name               string
	Limit              int32
}

type GetCollectiveCollectionByMaxAmountOfPlayersRow struct {
	GameID             int32
	Name               string
	Description        string
	Kind               KindEnum
	MinAmountOfPlayers int32
	MaxAmountOfPlayers int32
	LudopediaID        pgtype.Int4
	LudopediaUrl       pgtype.Text
	IconPath           pgtype.Text
	Owners             []byte
}

func (q *Queries) GetCollectiveCollectionByMaxAmountOfPlayers(ctx context.Context, arg GetCollectiveCollectionByMaxAmountOfPlayersParams) ([]GetCollectiveCollectionByMaxAmountOfPlayersRow, error) {
	rows, err := q.db.Query(ctx, getCollectiveCollectionByMaxAmountOfPlayers,
		arg.Kind,
		arg.MaxAmountOfPlayers,
		arg.Name,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectiveCollectionByMaxAmountOfPlayersRow
	for rows.Next() {
		var i GetCollectiveCollectionByMaxAmountOfPlayersRow
		if err := rows.Scan(
			&i.GameID,
			&i.Name,
			&i.Description,
			&i.Kind,
			&i.MinAmountOfPlayers,
			&i.MaxAmountOfPlayers,
			&i.LudopediaID,
			&i.LudopediaUrl,
			&i.IconPath,
			&i.Owners,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectiveCollectionByOwner = `-- name: GetCollectiveCollectionByOwner :many
SELECT
  g."id" AS "game_id",
  g."name",
  g."description",
  g."kind",
  g."min_amount_of_players",
  g."max_amount_of_players",
  g."ludopedia_id",
  g."ludopedia_url",
  g."icon_path",
  json_agg(
    json_build_object(
      'account_id', a."id",
      'handle', a."handle",
      'avatar_path', a."avatar_path"
    ) ORDER BY a."handle"
  ) FILTER (WHERE a.id IS NOT NULL) AS owners
FROM
  "games" g
INNER JOIN
  "personal_collections" pc ON g."id" = pc."game_id"
INNER JOIN
  "accounts" a ON pc."account_id" = a."id"
WHERE
	g."kind" = $1
	AND
	pc."account_id" = $2
	AND
	g."name" > $3
GROUP BY
  g."id"
ORDER BY
	g."name" ASC
LIMIT $4
`

type GetCollectiveCollectionByOwnerParams struct {
	Kind      KindEnum
	AccountID int32
	Name      string
	Limit     int32
}

type GetCollectiveCollectionByOwnerRow struct {
	GameID             int32
	Name               string
	Description        string
	Kind               KindEnum
	MinAmountOfPlayers int32
	MaxAmountOfPlayers int32
	LudopediaID        pgtype.Int4
	LudopediaUrl       pgtype.Text
	IconPath           pgtype.Text
	Owners             []byte
}

func (q *Queries) GetCollectiveCollectionByOwner(ctx context.Context, arg GetCollectiveCollectionByOwnerParams) ([]GetCollectiveCollectionByOwnerRow, error) {
	rows, err := q.db.Query(ctx, getCollectiveCollectionByOwner,
		arg.Kind,
		arg.AccountID,
		arg.Name,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectiveCollectionByOwnerRow
	for rows.Next() {
		var i GetCollectiveCollectionByOwnerRow
		if err := rows.Scan(
			&i.GameID,
			&i.Name,
			&i.Description,
			&i.Kind,
			&i.MinAmountOfPlayers,
			&i.MaxAmountOfPlayers,
			&i.LudopediaID,
			&i.LudopediaUrl,
			&i.IconPath,
			&i.Owners,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
