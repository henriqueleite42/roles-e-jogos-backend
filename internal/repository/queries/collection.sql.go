// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: collection.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addToPersonalCollection = `-- name: AddToPersonalCollection :exec
INSERT INTO "personal_collections" (
	"account_id",
	"game_id",
	"paid",
	"acquired_at"
) VALUES (
	$1,
	$2,
	$3,
	$4
)
`

type AddToPersonalCollectionParams struct {
	AccountID  int32
	GameID     int32
	Paid       pgtype.Int4
	AcquiredAt pgtype.Timestamptz
}

func (q *Queries) AddToPersonalCollection(ctx context.Context, arg AddToPersonalCollectionParams) error {
	_, err := q.db.Exec(ctx, addToPersonalCollection,
		arg.AccountID,
		arg.GameID,
		arg.Paid,
		arg.AcquiredAt,
	)
	return err
}

const getCollectiveCollection = `-- name: GetCollectiveCollection :many
SELECT
  g."id" AS "game_id",
  g."name",
  g."description",
  g."kind",
  g."min_amount_of_players",
  g."max_amount_of_players",
  g."ludopedia_id",
  g."ludopedia_url",
  g."icon_path",
  json_agg(
    json_build_object(
      'account_id', a."id",
      'handle', a."handle",
      'avatar_path', a."avatar_path"
    ) ORDER BY a."handle"
  ) AS owners
FROM
  "games" g
INNER JOIN
  "personal_collections" pc ON g."id" = pc."game_id"
INNER JOIN
  "accounts" a ON pc."account_id" = a."id"
WHERE
	g."kind" = $1
  AND ($2 = '' OR LOWER(g."name") LIKE LOWER('%' || $2 || '%'))
  AND ($3 = 0 OR pc."account_id" = $3)
  AND ($4 = 0 OR g."max_amount_of_players" >= $4)
  AND ($5 = '' OR g."name" > $5)
GROUP BY
  g."id"
ORDER BY
	g."name" ASC
LIMIT $6
`

type GetCollectiveCollectionParams struct {
	Kind    KindEnum
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
	Column5 interface{}
	Limit   int32
}

type GetCollectiveCollectionRow struct {
	GameID             int32
	Name               string
	Description        string
	Kind               KindEnum
	MinAmountOfPlayers int32
	MaxAmountOfPlayers int32
	LudopediaID        pgtype.Int4
	LudopediaUrl       pgtype.Text
	IconPath           pgtype.Text
	Owners             []byte
}

func (q *Queries) GetCollectiveCollection(ctx context.Context, arg GetCollectiveCollectionParams) ([]GetCollectiveCollectionRow, error) {
	rows, err := q.db.Query(ctx, getCollectiveCollection,
		arg.Kind,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectiveCollectionRow
	for rows.Next() {
		var i GetCollectiveCollectionRow
		if err := rows.Scan(
			&i.GameID,
			&i.Name,
			&i.Description,
			&i.Kind,
			&i.MinAmountOfPlayers,
			&i.MaxAmountOfPlayers,
			&i.LudopediaID,
			&i.LudopediaUrl,
			&i.IconPath,
			&i.Owners,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
