// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: collection.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addToPersonalCollection = `-- name: AddToPersonalCollection :exec
INSERT INTO "personal_collections" (
	"account_id",
	"game_id",
	"paid",
	"acquired_at"
) VALUES (
	$1,
	$2,
	$3,
	$4
) ON CONFLICT ("account_id", "game_id") DO NOTHING
`

type AddToPersonalCollectionParams struct {
	AccountID  int32
	GameID     int32
	Paid       pgtype.Int4
	AcquiredAt pgtype.Timestamptz
}

func (q *Queries) AddToPersonalCollection(ctx context.Context, arg AddToPersonalCollectionParams) error {
	_, err := q.db.Exec(ctx, addToPersonalCollection,
		arg.AccountID,
		arg.GameID,
		arg.Paid,
		arg.AcquiredAt,
	)
	return err
}

const createImportCollectionLog = `-- name: CreateImportCollectionLog :one
INSERT INTO "import_collection_logs" (
	"account_id",
	"external_id",
	"trigger",
	"provider",
	"status"
) VALUES (
	$1,
	$2,
	$3,
	$4,
	$5
) RETURNING "id"
`

type CreateImportCollectionLogParams struct {
	AccountID  int32
	ExternalID string
	Trigger    CollectionImportTriggerEnum
	Provider   ProviderEnum
	Status     CollectionImportStatusEnum
}

func (q *Queries) CreateImportCollectionLog(ctx context.Context, arg CreateImportCollectionLogParams) (int32, error) {
	row := q.db.QueryRow(ctx, createImportCollectionLog,
		arg.AccountID,
		arg.ExternalID,
		arg.Trigger,
		arg.Provider,
		arg.Status,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getCollectiveCollection = `-- name: GetCollectiveCollection :many
SELECT
  g."id" AS "game_id",
  g."name",
  g."description",
  g."kind",
  g."min_amount_of_players",
  g."max_amount_of_players",
  g."ludopedia_id",
  g."ludopedia_url",
  g."icon_path",
  json_agg(
    json_build_object(
      'account_id', a."id",
      'handle', a."handle",
      'avatar_path', a."avatar_path"
    ) ORDER BY a."handle"
  ) AS owners
FROM
  "games" g
INNER JOIN
  "personal_collections" pc ON g."id" = pc."game_id"
INNER JOIN
  "accounts" a ON pc."account_id" = a."id"
WHERE
	g."kind" = $1
  AND ($2 = '' OR LOWER(g."name") LIKE LOWER('%' || $2 || '%'))
  AND ($3 = 0 OR pc."account_id" = $3)
  AND ($4 = 0 OR g."max_amount_of_players" >= $4)
  AND ($5 = '' OR g."name" > $5)
GROUP BY
  g."id"
ORDER BY
	g."name" ASC
LIMIT $6
`

type GetCollectiveCollectionParams struct {
	Kind    KindEnum
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
	Column5 interface{}
	Limit   int32
}

type GetCollectiveCollectionRow struct {
	GameID             int32
	Name               string
	Description        string
	Kind               KindEnum
	MinAmountOfPlayers int32
	MaxAmountOfPlayers int32
	LudopediaID        pgtype.Int4
	LudopediaUrl       pgtype.Text
	IconPath           pgtype.Text
	Owners             []byte
}

func (q *Queries) GetCollectiveCollection(ctx context.Context, arg GetCollectiveCollectionParams) ([]GetCollectiveCollectionRow, error) {
	rows, err := q.db.Query(ctx, getCollectiveCollection,
		arg.Kind,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectiveCollectionRow
	for rows.Next() {
		var i GetCollectiveCollectionRow
		if err := rows.Scan(
			&i.GameID,
			&i.Name,
			&i.Description,
			&i.Kind,
			&i.MinAmountOfPlayers,
			&i.MaxAmountOfPlayers,
			&i.LudopediaID,
			&i.LudopediaUrl,
			&i.IconPath,
			&i.Owners,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestImportCollectionLog = `-- name: GetLatestImportCollectionLog :one
SELECT
	icl."id",
	icl."account_id",
	icl."external_id",
	icl."provider",
	icl."trigger",
	icl."status",
	icl."created_at",
	icl."ended_at"
FROM "import_collection_logs" icl
INNER JOIN "connections" c ON c."external_id" = icl."external_id"
WHERE
	c."account_id" = $1
	AND icl."external_id" = $2
	AND icl."provider" = $3
ORDER BY
	icl."created_at" DESC
LIMIT 1
`

type GetLatestImportCollectionLogParams struct {
	AccountID  int32
	ExternalID string
	Provider   ProviderEnum
}

type GetLatestImportCollectionLogRow struct {
	ID         int32
	AccountID  int32
	ExternalID string
	Provider   ProviderEnum
	Trigger    CollectionImportTriggerEnum
	Status     CollectionImportStatusEnum
	CreatedAt  pgtype.Timestamptz
	EndedAt    pgtype.Timestamptz
}

func (q *Queries) GetLatestImportCollectionLog(ctx context.Context, arg GetLatestImportCollectionLogParams) (GetLatestImportCollectionLogRow, error) {
	row := q.db.QueryRow(ctx, getLatestImportCollectionLog, arg.AccountID, arg.ExternalID, arg.Provider)
	var i GetLatestImportCollectionLogRow
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.ExternalID,
		&i.Provider,
		&i.Trigger,
		&i.Status,
		&i.CreatedAt,
		&i.EndedAt,
	)
	return i, err
}

const getOngoingImportCollectionLog = `-- name: GetOngoingImportCollectionLog :many
SELECT
	icl."id",
	icl."account_id",
	icl."external_id",
	icl."provider",
	icl."trigger",
	icl."status",
	icl."created_at"
FROM "import_collection_logs" icl
WHERE
	icl."external_id" = ANY($1::text[])
	AND icl."provider" = $2
	AND icl."ended_at" IS NULL
`

type GetOngoingImportCollectionLogParams struct {
	Column1  []string
	Provider ProviderEnum
}

type GetOngoingImportCollectionLogRow struct {
	ID         int32
	AccountID  int32
	ExternalID string
	Provider   ProviderEnum
	Trigger    CollectionImportTriggerEnum
	Status     CollectionImportStatusEnum
	CreatedAt  pgtype.Timestamptz
}

func (q *Queries) GetOngoingImportCollectionLog(ctx context.Context, arg GetOngoingImportCollectionLogParams) ([]GetOngoingImportCollectionLogRow, error) {
	rows, err := q.db.Query(ctx, getOngoingImportCollectionLog, arg.Column1, arg.Provider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOngoingImportCollectionLogRow
	for rows.Next() {
		var i GetOngoingImportCollectionLogRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.ExternalID,
			&i.Provider,
			&i.Trigger,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateManyImportCollectionsLogs = `-- name: UpdateManyImportCollectionsLogs :exec
UPDATE "import_collection_logs"
SET
	"status" = $2,
	"ended_at" = NOW()
WHERE
	"id" = ANY($1::int[])
	AND "ended_at" IS NULL
`

type UpdateManyImportCollectionsLogsParams struct {
	Column1 []int32
	Status  CollectionImportStatusEnum
}

func (q *Queries) UpdateManyImportCollectionsLogs(ctx context.Context, arg UpdateManyImportCollectionsLogsParams) error {
	_, err := q.db.Exec(ctx, updateManyImportCollectionsLogs, arg.Column1, arg.Status)
	return err
}
