// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: account.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAccount = `-- name: CreateAccount :one
INSERT INTO "accounts" (
	"handle",
	"name",
	"avatar_path"
) VALUES (
	$1,
	$2,
	$3
) RETURNING "id"
`

type CreateAccountParams struct {
	Handle     string
	Name       pgtype.Text
	AvatarPath pgtype.Text
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (int32, error) {
	row := q.db.QueryRow(ctx, createAccount, arg.Handle, arg.Name, arg.AvatarPath)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createConnection = `-- name: CreateConnection :exec
INSERT INTO "connections" (
	"account_id",
	"external_handle",
	"external_id",
	"provider",
	"access_token",
	"refresh_token"
) VALUES (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6
)
`

type CreateConnectionParams struct {
	AccountID      int32
	ExternalHandle pgtype.Text
	ExternalID     string
	Provider       ProviderEnum
	AccessToken    pgtype.Text
	RefreshToken   pgtype.Text
}

func (q *Queries) CreateConnection(ctx context.Context, arg CreateConnectionParams) error {
	_, err := q.db.Exec(ctx, createConnection,
		arg.AccountID,
		arg.ExternalHandle,
		arg.ExternalID,
		arg.Provider,
		arg.AccessToken,
		arg.RefreshToken,
	)
	return err
}

const createOtp = `-- name: CreateOtp :exec
INSERT INTO "one_time_passwords" (
	"account_id",
	"code",
	"purpose"
) VALUES (
	$1,
	$2,
	$3
)
`

type CreateOtpParams struct {
	AccountID int32
	Code      string
	Purpose   OtpPurposeEnum
}

func (q *Queries) CreateOtp(ctx context.Context, arg CreateOtpParams) error {
	_, err := q.db.Exec(ctx, createOtp, arg.AccountID, arg.Code, arg.Purpose)
	return err
}

const createSession = `-- name: CreateSession :exec
INSERT INTO "sessions" (
	"session_id",
	"account_id"
) VALUES (
	$1,
	$2
)
`

type CreateSessionParams struct {
	SessionID string
	AccountID int32
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) error {
	_, err := q.db.Exec(ctx, createSession, arg.SessionID, arg.AccountID)
	return err
}

const createValidatedEmailAddress = `-- name: CreateValidatedEmailAddress :exec
INSERT INTO "email_addresses" (
	"account_id",
	"email_address",
	"validated_at"
) VALUES (
	$1,
	$2,
	NOW()
) ON CONFLICT DO NOTHING
`

type CreateValidatedEmailAddressParams struct {
	AccountID    int32
	EmailAddress string
}

func (q *Queries) CreateValidatedEmailAddress(ctx context.Context, arg CreateValidatedEmailAddressParams) error {
	_, err := q.db.Exec(ctx, createValidatedEmailAddress, arg.AccountID, arg.EmailAddress)
	return err
}

const getAccountByHandle = `-- name: GetAccountByHandle :one
SELECT
	a.avatar_path, a.created_at, a.handle, a.id, a.is_admin, a.name
FROM "accounts" a
WHERE
	a."handle" = $1
LIMIT 1
`

func (q *Queries) GetAccountByHandle(ctx context.Context, handle string) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByHandle, handle)
	var i Account
	err := row.Scan(
		&i.AvatarPath,
		&i.CreatedAt,
		&i.Handle,
		&i.ID,
		&i.IsAdmin,
		&i.Name,
	)
	return i, err
}

const getAccountById = `-- name: GetAccountById :one
SELECT
	a.avatar_path, a.created_at, a.handle, a.id, a.is_admin, a.name
FROM "accounts" a
WHERE
	a."id" = $1
LIMIT 1
`

func (q *Queries) GetAccountById(ctx context.Context, id int32) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountById, id)
	var i Account
	err := row.Scan(
		&i.AvatarPath,
		&i.CreatedAt,
		&i.Handle,
		&i.ID,
		&i.IsAdmin,
		&i.Name,
	)
	return i, err
}

const getAccountDataByConnection = `-- name: GetAccountDataByConnection :one
SELECT
	c."account_id",
	a."is_admin"
FROM "connections" c
LEFT JOIN "accounts" a ON c."account_id" = a."id"
WHERE
	c."provider" = $1
	AND
	c."external_id" = $2
LIMIT 1
`

type GetAccountDataByConnectionParams struct {
	Provider   ProviderEnum
	ExternalID string
}

type GetAccountDataByConnectionRow struct {
	AccountID int32
	IsAdmin   pgtype.Bool
}

func (q *Queries) GetAccountDataByConnection(ctx context.Context, arg GetAccountDataByConnectionParams) (GetAccountDataByConnectionRow, error) {
	row := q.db.QueryRow(ctx, getAccountDataByConnection, arg.Provider, arg.ExternalID)
	var i GetAccountDataByConnectionRow
	err := row.Scan(&i.AccountID, &i.IsAdmin)
	return i, err
}

const getAccountDataByEmail = `-- name: GetAccountDataByEmail :one
SELECT
	e."account_id",
	a."is_admin"
FROM
	"email_addresses" e
LEFT JOIN "accounts" a ON e."account_id" = a."id"
WHERE
	e."email_address" = $1
LIMIT 1
`

type GetAccountDataByEmailRow struct {
	AccountID int32
	IsAdmin   pgtype.Bool
}

func (q *Queries) GetAccountDataByEmail(ctx context.Context, emailAddress string) (GetAccountDataByEmailRow, error) {
	row := q.db.QueryRow(ctx, getAccountDataByEmail, emailAddress)
	var i GetAccountDataByEmailRow
	err := row.Scan(&i.AccountID, &i.IsAdmin)
	return i, err
}

const getAccountDataByEmailOrConnection = `-- name: GetAccountDataByEmailOrConnection :one
(SELECT
	c."account_id",
	a."is_admin"
FROM
	"connections" c
LEFT JOIN "accounts" a ON c."account_id" = a."id"
WHERE
	c."provider" = $1
	AND
	c."external_id" = $2
LIMIT 1)
UNION
(SELECT
	e."account_id",
	a."is_admin"
FROM
	"email_addresses" e
LEFT JOIN "accounts" a ON e."account_id" = a."id"
WHERE
	e."email_address" = $3
LIMIT 1)
`

type GetAccountDataByEmailOrConnectionParams struct {
	Provider     ProviderEnum
	ExternalID   string
	EmailAddress string
}

type GetAccountDataByEmailOrConnectionRow struct {
	AccountID int32
	IsAdmin   pgtype.Bool
}

func (q *Queries) GetAccountDataByEmailOrConnection(ctx context.Context, arg GetAccountDataByEmailOrConnectionParams) (GetAccountDataByEmailOrConnectionRow, error) {
	row := q.db.QueryRow(ctx, getAccountDataByEmailOrConnection, arg.Provider, arg.ExternalID, arg.EmailAddress)
	var i GetAccountDataByEmailOrConnectionRow
	err := row.Scan(&i.AccountID, &i.IsAdmin)
	return i, err
}

const getAccountDataByHandle = `-- name: GetAccountDataByHandle :one
SELECT
	a."id",
	a."is_admin"
FROM "accounts" a
WHERE
	a."handle" = $1
LIMIT 1
`

type GetAccountDataByHandleRow struct {
	ID      int32
	IsAdmin bool
}

func (q *Queries) GetAccountDataByHandle(ctx context.Context, handle string) (GetAccountDataByHandleRow, error) {
	row := q.db.QueryRow(ctx, getAccountDataByHandle, handle)
	var i GetAccountDataByHandleRow
	err := row.Scan(&i.ID, &i.IsAdmin)
	return i, err
}

const getAccountDataById = `-- name: GetAccountDataById :one
SELECT
	a."id",
	a."is_admin"
FROM "accounts" a
WHERE
	a."id" = $1
LIMIT 1
`

type GetAccountDataByIdRow struct {
	ID      int32
	IsAdmin bool
}

func (q *Queries) GetAccountDataById(ctx context.Context, id int32) (GetAccountDataByIdRow, error) {
	row := q.db.QueryRow(ctx, getAccountDataById, id)
	var i GetAccountDataByIdRow
	err := row.Scan(&i.ID, &i.IsAdmin)
	return i, err
}

const getAccountDataBySession = `-- name: GetAccountDataBySession :one
SELECT
	a."id",
	a."is_admin",
	a."handle",
	a."avatar_path"
FROM "sessions" s
LEFT JOIN "accounts" a ON a."id" = s."account_id"
WHERE
	s."session_id" = $1
LIMIT 1
`

type GetAccountDataBySessionRow struct {
	ID         pgtype.Int4
	IsAdmin    pgtype.Bool
	Handle     pgtype.Text
	AvatarPath pgtype.Text
}

func (q *Queries) GetAccountDataBySession(ctx context.Context, sessionID string) (GetAccountDataBySessionRow, error) {
	row := q.db.QueryRow(ctx, getAccountDataBySession, sessionID)
	var i GetAccountDataBySessionRow
	err := row.Scan(
		&i.ID,
		&i.IsAdmin,
		&i.Handle,
		&i.AvatarPath,
	)
	return i, err
}

const getAccountsListByIds = `-- name: GetAccountsListByIds :many
SELECT
	a."avatar_path",
	a."created_at",
	a."handle",
	a."id",
	a."name"
FROM "accounts" a
WHERE
	a."id" = ANY($1::int[])
`

type GetAccountsListByIdsRow struct {
	AvatarPath pgtype.Text
	CreatedAt  pgtype.Timestamptz
	Handle     string
	ID         int32
	Name       pgtype.Text
}

func (q *Queries) GetAccountsListByIds(ctx context.Context, dollar_1 []int32) ([]GetAccountsListByIdsRow, error) {
	rows, err := q.db.Query(ctx, getAccountsListByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccountsListByIdsRow
	for rows.Next() {
		var i GetAccountsListByIdsRow
		if err := rows.Scan(
			&i.AvatarPath,
			&i.CreatedAt,
			&i.Handle,
			&i.ID,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConnection = `-- name: GetConnection :one
SELECT
	c."account_id",
	c."provider",
	c."external_handle",
	c."external_id",
	c."access_token",
	c."refresh_token",
	c."created_at"
FROM "connections" c
WHERE
	c."external_id" = $1
	AND
	c."provider" = $2
LIMIT 1
`

type GetConnectionParams struct {
	ExternalID string
	Provider   ProviderEnum
}

type GetConnectionRow struct {
	AccountID      int32
	Provider       ProviderEnum
	ExternalHandle pgtype.Text
	ExternalID     string
	AccessToken    pgtype.Text
	RefreshToken   pgtype.Text
	CreatedAt      pgtype.Timestamptz
}

func (q *Queries) GetConnection(ctx context.Context, arg GetConnectionParams) (GetConnectionRow, error) {
	row := q.db.QueryRow(ctx, getConnection, arg.ExternalID, arg.Provider)
	var i GetConnectionRow
	err := row.Scan(
		&i.AccountID,
		&i.Provider,
		&i.ExternalHandle,
		&i.ExternalID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.CreatedAt,
	)
	return i, err
}

const getConnectionsByAccountId = `-- name: GetConnectionsByAccountId :many
SELECT
	c."account_id",
	c."provider",
	c."external_handle",
	c."external_id",
	c."access_token",
	c."refresh_token",
	c."created_at"
FROM "connections" c
WHERE
	c."account_id" = $1
`

type GetConnectionsByAccountIdRow struct {
	AccountID      int32
	Provider       ProviderEnum
	ExternalHandle pgtype.Text
	ExternalID     string
	AccessToken    pgtype.Text
	RefreshToken   pgtype.Text
	CreatedAt      pgtype.Timestamptz
}

func (q *Queries) GetConnectionsByAccountId(ctx context.Context, accountID int32) ([]GetConnectionsByAccountIdRow, error) {
	rows, err := q.db.Query(ctx, getConnectionsByAccountId, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConnectionsByAccountIdRow
	for rows.Next() {
		var i GetConnectionsByAccountIdRow
		if err := rows.Scan(
			&i.AccountID,
			&i.Provider,
			&i.ExternalHandle,
			&i.ExternalID,
			&i.AccessToken,
			&i.RefreshToken,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailsByAccountsIds = `-- name: GetEmailsByAccountsIds :many
SELECT DISTINCT ON (ea."account_id")
	ea."email_address",
	ea."account_id",
	ea."created_at",
	ea."validated_at"
FROM "email_addresses" ea
WHERE
	ea."account_id" = ANY($1::int[])
ORDER BY
	ea."created_at" ASC
`

type GetEmailsByAccountsIdsRow struct {
	EmailAddress string
	AccountID    int32
	CreatedAt    pgtype.Timestamptz
	ValidatedAt  pgtype.Timestamptz
}

func (q *Queries) GetEmailsByAccountsIds(ctx context.Context, dollar_1 []int32) ([]GetEmailsByAccountsIdsRow, error) {
	rows, err := q.db.Query(ctx, getEmailsByAccountsIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmailsByAccountsIdsRow
	for rows.Next() {
		var i GetEmailsByAccountsIdsRow
		if err := rows.Scan(
			&i.EmailAddress,
			&i.AccountID,
			&i.CreatedAt,
			&i.ValidatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOtp = `-- name: GetOtp :one
SELECT
	otp."created_at"
FROM "one_time_passwords" otp
WHERE
	otp."account_id" = $1
	AND
	otp."code" = $2
	AND
	otp."purpose" = $3
LIMIT 1
`

type GetOtpParams struct {
	AccountID int32
	Code      string
	Purpose   OtpPurposeEnum
}

func (q *Queries) GetOtp(ctx context.Context, arg GetOtpParams) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getOtp, arg.AccountID, arg.Code, arg.Purpose)
	var created_at pgtype.Timestamptz
	err := row.Scan(&created_at)
	return created_at, err
}

const getValidatedEmailsByAccountsIds = `-- name: GetValidatedEmailsByAccountsIds :many
SELECT DISTINCT ON (ea."account_id")
	ea."email_address",
	ea."account_id",
	ea."created_at",
	ea."validated_at"
FROM "email_addresses" ea
WHERE
	ea."account_id" = ANY($1::int[])
	AND
	ea."validated_at" IS NOT NULL
ORDER BY
	ea."created_at" ASC
`

type GetValidatedEmailsByAccountsIdsRow struct {
	EmailAddress string
	AccountID    int32
	CreatedAt    pgtype.Timestamptz
	ValidatedAt  pgtype.Timestamptz
}

func (q *Queries) GetValidatedEmailsByAccountsIds(ctx context.Context, dollar_1 []int32) ([]GetValidatedEmailsByAccountsIdsRow, error) {
	rows, err := q.db.Query(ctx, getValidatedEmailsByAccountsIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetValidatedEmailsByAccountsIdsRow
	for rows.Next() {
		var i GetValidatedEmailsByAccountsIdsRow
		if err := rows.Scan(
			&i.EmailAddress,
			&i.AccountID,
			&i.CreatedAt,
			&i.ValidatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccountHandle = `-- name: UpdateAccountHandle :exec
UPDATE "accounts" SET
	"handle" = $2
WHERE
	"id" = $1
`

type UpdateAccountHandleParams struct {
	ID     int32
	Handle string
}

func (q *Queries) UpdateAccountHandle(ctx context.Context, arg UpdateAccountHandleParams) error {
	_, err := q.db.Exec(ctx, updateAccountHandle, arg.ID, arg.Handle)
	return err
}

const updateAccountName = `-- name: UpdateAccountName :exec
UPDATE "accounts" SET
	"name" = $2
WHERE
	"id" = $1
`

type UpdateAccountNameParams struct {
	ID   int32
	Name pgtype.Text
}

func (q *Queries) UpdateAccountName(ctx context.Context, arg UpdateAccountNameParams) error {
	_, err := q.db.Exec(ctx, updateAccountName, arg.ID, arg.Name)
	return err
}

const updateAccountProfile = `-- name: UpdateAccountProfile :exec
UPDATE "accounts" SET
	"name" = COALESCE($2, "name")
WHERE "id" = $1
`

type UpdateAccountProfileParams struct {
	ID   int32
	Name pgtype.Text
}

func (q *Queries) UpdateAccountProfile(ctx context.Context, arg UpdateAccountProfileParams) error {
	_, err := q.db.Exec(ctx, updateAccountProfile, arg.ID, arg.Name)
	return err
}

const updateConnection = `-- name: UpdateConnection :exec
UPDATE "connections" SET
	"refresh_token" = COALESCE($4, "refresh_token"),
	"external_handle" = COALESCE($5, "external_handle")
WHERE
	"account_id" = $1
	AND
	"provider" = $2
	AND
	"external_id" = $3
`

type UpdateConnectionParams struct {
	AccountID      int32
	Provider       ProviderEnum
	ExternalID     string
	RefreshToken   pgtype.Text
	ExternalHandle pgtype.Text
}

func (q *Queries) UpdateConnection(ctx context.Context, arg UpdateConnectionParams) error {
	_, err := q.db.Exec(ctx, updateConnection,
		arg.AccountID,
		arg.Provider,
		arg.ExternalID,
		arg.RefreshToken,
		arg.ExternalHandle,
	)
	return err
}
